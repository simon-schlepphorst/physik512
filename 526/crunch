#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Copyright © 2013-2015 Martin Ueding <dev@martin-ueding.de>
# Licensed under The GNU Public License Version 2 (or later)

import itertools
import json
import os.path
import pprint
import re
import sys

import matplotlib.pyplot as pl
import matplotlib.colors
import numpy as np
import scipy.misc
import scipy.ndimage.filters
import scipy.optimize as op
import scipy.stats
import scipy.integrate
import scipy.interpolate
import unitprint

_livetime_pattern = re.compile(r'LIVETIME: (\d+\.?\d*)')

def gauss_peak(x, mean, width, area):
    '''
    Gausskurve
    '''
    return area / (width * np.sqrt(2 * np.pi)) * np.exp( - ((x - mean) / width)**2 / 2)

def decay(x, a):
    '''
    Exponentieller Abfall
    '''
    return np.exp(- x * a)

def linear(x, slope, offset):
    return x * slope + offset

def linear_err(x, x_err, slope_val, slope_err, offset_val, offset_err):
    return np.sqrt((x_err * slope_val)**2 + (x * slope_err)**2 + offset_err**2)

def extract_livetime(metafile):
    with open(metafile) as f:
        for line in f:
            m = _livetime_pattern.search(line)
            if m:
                return float(m.group(1))

def load_data_normalized(basename, lower_cut=0, upper_cut=-1):
    '''
    Loads the data and normalizes it to give events per second.
    '''
    datafile = 'Daten/' + basename + '.txt'
    metafile = 'Daten/' + basename + '.mcd'

    livetime = extract_livetime(metafile)

    data = np.loadtxt(datafile)

    data[:, 1] /= livetime

    data = data[lower_cut:upper_cut]

    return data

def fit_peak(name, data, first, last, energy, save=False, clear=True):
    '''
    Passt einen Peak an
    :save speichert gesamtes Spektrum in Datei
    :clear False setzt die Figure nicht zurück und speichert nicht

    :return Mittelpunkt, Fehler Mittelpunkt, Breite, Fehler Breite, Fläche, Fehler Fläche, Energie
    '''

    x, y = data[first:last, 0], data[first:last, 1]
    popt, pconv = op.curve_fit(gauss_peak, x, y, p0=[np.mean(x), 200, 100])
    perr = np.sqrt(pconv.diagonal())

    if save:
        fig = pl.figure()
        ax = fig.add_subplot(1, 1, 1)

        x, y = data[:, 0], data[:, 1]

        fit_x = np.linspace(np.min(x), np.max(x), 1000)
        fit_y = gauss_peak(fit_x, *popt)

        ax.plot(x, y, marker=None)
        ax.plot(fit_x, fit_y, marker=None)
        ax.margins(0.05)
        ax.grid(True)
        ax.set_xlabel('Kanal')
        ax.set_ylabel('Ereignisse / s')
        fig.tight_layout()
        if clear:
            fig.savefig('_build/plot_fit_peak_'+ name +'.pdf')
            fig.clear

    return popt[0], perr[0], popt[1], perr[1], popt[2], perr[2], energy


def job_total_cross_section(T):
    lower_cut = 200
    upper_cut = 8000

    data_untergrund = load_data_normalized('m01_untergrund', lower_cut, upper_cut)
    data_01mm = load_data_normalized('m01_1mm', lower_cut, upper_cut)
    data_05mm = load_data_normalized('m01_5mm', lower_cut, upper_cut)
    data_10mm = load_data_normalized('m01_10mm', lower_cut, upper_cut)
    data_20mm = load_data_normalized('m01_20mm', lower_cut, upper_cut)

    fig = pl.figure()
    ax = fig.add_subplot(1, 1, 1)

    points = []

    first = 6200 - lower_cut
    last = 7600 - lower_cut

    for name, data, color in [('ohne', data_untergrund,'#e41a1c'),
                              ('01mm', data_01mm, '#377eb9'),
                              ('05mm', data_05mm, '#4daf4a'),
                              ('10mm', data_10mm, '#984ea4'),
                              ('20mm', data_20mm, '#ff7f01')]:
        points.append(fit_peak(name, data, first, last, 662, save=True))
        tmp_point = np.array(points[-1])
        x, y = data[first:last, 0], data[first:last, 1]
        fit_x = np.linspace(np.min(x), np.max(x), 1000)
        fit_y = gauss_peak(fit_x, tmp_point[-7], tmp_point[-5], tmp_point[-3])

        ax.plot(x, y, marker=None, alpha=0.4, color=color)
        ax.plot(fit_x, fit_y, marker = None, color=color, label=name, linewidth=2)

    ax.margins(0.05)
    ax.grid(True)
    ax.set_xlabel('Kanal')
    ax.set_ylabel('Ereignisse / s')
    ax.legend(loc='best')
    fig.tight_layout()
    fig.savefig('_build/total-cross-section-data.pdf')
    fig.clear

    points = np.array(points)

    list_dicke = np.array([0, 1, 5, 10, 20])
    list_mean_val = points[:, 0]
    list_mean_err = points[:, 1]
    list_full_width_val = points[:, 2] * 2 * np.sqrt(2 * np.log(2))
    list_full_width_err = points[:, 3] * 2 * np.sqrt(2 * np.log(2))
    list_area_val = points[:, 4]
    list_area_err = points[:, 5]


    # Relative Intensität bestimmen:

    list_intensity_val = np.copy(list_area_val)
    list_intensity_err = np.copy(list_area_err)
    #list_intensity_val = list_area_val * list_mean_val
    #list_intensity_err = np.sqrt(
    #    (list_area_err * list_mean_val)**2
    #    + (list_area_val * list_mean_err)**2
    #)

    rescale = list_intensity_val[0]

    list_intensity_val /= rescale
    list_intensity_err /= rescale

    popt, pconv = op.curve_fit(decay, list_dicke[:-1], list_intensity_val[:-1], p0=[1])
    perr = np.sqrt(pconv.diagonal())
    x = np.linspace(np.min(list_dicke), np.max(list_dicke), 100)
    y = decay(x, *popt)

    fig = pl.figure()
    ax = fig.add_subplot(1, 1, 1)

    ax.errorbar(list_dicke, list_intensity_val, list_intensity_err, marker='+', linestyle='none')
    ax.plot(x, y)

    ax.margins(0.05)
    ax.grid(True)
    ax.set_xlabel('Dicke')
    ax.set_ylabel('relative Intensität')
    fig.tight_layout()
    fig.savefig('_build/total-cross-section-fit.pdf')
    fig.clear


    T['total_cross_section_table'] = list(zip(
        unitprint.siunitx(list_dicke),
        unitprint.siunitx(list_mean_val, list_mean_err),
        unitprint.siunitx(list_full_width_val, list_full_width_err),
        unitprint.siunitx(list_intensity_val, list_intensity_err),
        ))

    # Absorbtionseigenschaften von Aluminium

    dichte = 2.7
    amu = 26.98
    na = 6.022e23

    n = dichte * na / amu

    sigma_val = np.log(popt[0]) / n
    sigma_err = np.log(perr[0]) / n

    T['alu_dichte'] = unitprint.siunitx(dichte)
    T['alu_amu'] = unitprint.siunitx(amu)
    T['alu_n'] = unitprint.siunitx(n)
    T['alu_a'] = unitprint.siunitx(popt[0], perr[0])
    T['alu_sigma'] = unitprint.siunitx(sigma_val / 1e-22, sigma_err / 1e-22)



def test_keys(T):
    '''
    Testet das dict auf Schlüssel mit Bindestrichen.
    '''
    dash_keys = []
    for key in T:
        if '-' in key:
            dash_keys.append(key)

    if len(dash_keys) > 0:
        print()
        print('**************************************************************')
        print('* Es dürfen keine Bindestriche in den Schlüsseln für T sein! *')
        print('**************************************************************')
        print()
        print('Folgende Schlüssel enthalten Bindestriche:')
        for dash_key in dash_keys:
            print('-', dash_key)
        print()
        sys.exit(100)

def main():
    T = {}

    ###########################################

    job_total_cross_section(T)

    ###########################################


    test_keys(T)
    with open('_build/template.js', 'w') as f:
        json.dump(dict(T), f, indent=4, sort_keys=True)

if __name__ == "__main__":
    main()
